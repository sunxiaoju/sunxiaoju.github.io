<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图片懒加载</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/lazy-image/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/lazy-image/</url>
      
        <content type="html"><![CDATA[<h2 id="图片懒加载的两种种实现方式"><a href="#图片懒加载的两种种实现方式" class="headerlink" title="图片懒加载的两种种实现方式"></a>图片懒加载的两种种实现方式</h2><p>在web开发中，通常需要考虑一些性能方面的优化，这里记录一下常见的优化点之一 —- 图片懒加载</p><p>那么什么是懒加载呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">懒加载是延迟加载一些资源（如：图片）的一种策略，以用户的行为和导航模式为依据，判断图片在被需要的时候才加载。通常来说，仅当这些资源滚动到视图中才被加载?</span><br></pre></td></tr></table></figure><h3 id="lazy-—–-采用浏览器提供的的支持方式"><a href="#lazy-—–-采用浏览器提供的的支持方式" class="headerlink" title="lazy —– 采用浏览器提供的的支持方式"></a>lazy —– 采用浏览器提供的的支持方式</h3><p>新版浏览器中已经支持image/iframe的懒加载，仅需在img/iframe元素中添加 loading=”lazy”属性，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;1.jpg&quot;</span> alt=<span class="string">&quot;alt&quot;</span> loading=<span class="string">&quot;lazy&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>浏览器支持版本<br> <img src="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/lazy-image/loading.png" alt="image"></p><h4 id="关键点：-必须要给img设置width和height属性"><a href="#关键点：-必须要给img设置width和height属性" class="headerlink" title="关键点： 必须要给img设置width和height属性"></a>关键点： 必须要给img设置width和height属性</h4><ul><li>懒加载的原理是利用图片的高度和时区的高度来进行计算的，如果图片没有设置高度，那么就是0，无论放多少图片， 都是为在可视区域的范围之内，会立马进行加载</li><li>默认加载差不多2页左右的图片数据，当然这个跟图片所在的容器有关系，而不是跟浏览器有关系</li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li>loading=”eager”跟loading=”lazy”相反，意思是不懒加载，直接加载，一般用不上</li><li>如何判断浏览器是否支持懒加载呢？<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//true 为支持</span></span><br><span class="line"><span class="keyword">const</span> isSupportLoading = <span class="string">&#x27;loading&#x27;</span> <span class="keyword">in</span> <span class="title class_">HTMLImageElement</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>优点： 直接添加属性就行<br>缺点： 老版本的浏览器不支持</p><h3 id="通过代码监听滚动方式实现"><a href="#通过代码监听滚动方式实现" class="headerlink" title="通过代码监听滚动方式实现"></a>通过代码监听滚动方式实现</h3><p>代码示例一： 滚动事件+函数节流  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;img src=&quot;./img/pixel.gif&quot; data-url=&quot;./img/1.jpeg&quot;&gt;</span></span><br><span class="line"><span class="keyword">let</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 一上来立即执行一次</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="comment">// 2. 监听滚动事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="title function_">lazyload</span>(fn, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取视口高度和内容的偏移量</span></span><br><span class="line">    <span class="keyword">let</span> clietH = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="variable language_">window</span>.<span class="property">pageYOffset</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(clietH, scrollTop);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = scrollTop + clietH - imgs[i].<span class="property">offsetTop</span> <span class="comment">//当内容的偏移量+视口高度&gt;图片距离内容顶部的偏移量时，说明图片在视口内</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            imgs[i].<span class="property">src</span> = imgs[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-url&#x27;</span>); <span class="comment">//从dataurl中取出真实的图片地址赋值给url</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params">fn, immediate</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, <span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码示例三： 滚动监听+getBoundingClientRect()</p><p>语法参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// &lt;img src=&quot;./img/pixel.gif&quot; data-url=&quot;./img/1.jpeg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">  <span class="comment">// 1. 一上来立即执行一次</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">  <span class="comment">// 2. 监听滚动事件</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="title function_">lazyload</span>(fn, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 获取视口高度和内容的偏移量</span></span><br><span class="line">      <span class="keyword">let</span> offsetHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">      <span class="title class_">Array</span>.<span class="title function_">from</span>(imgs).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> oBounding = item.<span class="title function_">getBoundingClientRect</span>() <span class="comment">//返回一个矩形对象，包含上下左右的偏移值</span></span><br><span class="line">          <span class="comment">// console.log(index, oBounding.top, offsetHeight);</span></span><br><span class="line">            <span class="comment">// 当前图片的top值大于0，top值小于可视高度，证明进入了可视区域内</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="number">0</span> &lt;= oBounding.<span class="property">top</span> &amp;&amp; oBounding.<span class="property">top</span> &lt;= offsetHeight) &#123;</span><br><span class="line">              item.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-url&#x27;</span>))</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数节流</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params">fn, immediate</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">          <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">              timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>)</span><br><span class="line">                  timer = <span class="literal">null</span></span><br><span class="line">              &#125;, <span class="number">200</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码示例三： intersectionObserve  – 通过进入可视区域进行判断</p><p>语法参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver">https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到所有的图片</span></span><br><span class="line"><span class="keyword">let</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. 一上来立即执行一次</span></span><br><span class="line"><span class="keyword">let</span> io = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="keyword">function</span> (<span class="params">entires</span>) &#123;</span><br><span class="line">    <span class="comment">//图片进入视口时就执行回调</span></span><br><span class="line">    entires.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取目标元素</span></span><br><span class="line">        <span class="keyword">let</span> oImg = item.<span class="property">target</span></span><br><span class="line">        <span class="comment">// 当图片进入视口的时候，就赋值图片的真实地址</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">intersectionRatio</span> &gt; <span class="number">0</span> &amp;&amp; item.<span class="property">intersectionRatio</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            oImg.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, oImg.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-url&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(imgs).<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">    io.<span class="title function_">observe</span>(element)  <span class="comment">//给每一个图片设置监听</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react问题集</title>
      <link href="/react/dailyInfo/"/>
      <url>/react/dailyInfo/</url>
      
        <content type="html"><![CDATA[<h3 id="react中路由跳转后页面不置顶问题-从页面A跳转到页面B，页面A滚动到中间位置，跳转后页面B也会在中间位置"><a href="#react中路由跳转后页面不置顶问题-从页面A跳转到页面B，页面A滚动到中间位置，跳转后页面B也会在中间位置" class="headerlink" title="react中路由跳转后页面不置顶问题: 从页面A跳转到页面B，页面A滚动到中间位置，跳转后页面B也会在中间位置"></a>react中路由跳转后页面不置顶问题: 从页面A跳转到页面B，页面A滚动到中间位置，跳转后页面B也会在中间位置</h3><h3 id="解决方法：在顶部组件的生命周期中进行判断，例如："><a href="#解决方法：在顶部组件的生命周期中进行判断，例如：" class="headerlink" title="解决方法：在顶部组件的生命周期中进行判断，例如："></a>解决方法：在顶部组件的生命周期中进行判断，例如：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>)&#123;​​​​​​</span><br><span class="line">　　<span class="comment">//当路由切换到新页面时置顶</span></span><br><span class="line">　　<span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span> !== nextProps.<span class="property">location</span>)&#123;​​​​​​</span><br><span class="line">　　　　<span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">　　&#125;​​​​​​</span><br><span class="line">&#125;​​​​​</span><br></pre></td></tr></table></figure><br><span id="more"></span><hr><h2 id="在async-await的方法函数中使用setState的问题"><a href="#在async-await的方法函数中使用setState的问题" class="headerlink" title="在async/await的方法函数中使用setState的问题"></a>在async/await的方法函数中使用setState的问题</h2><p>在正常的函数方法中调用时，使用的setState()是一个异步处理的过程，但是如果在async 的方法中使用setState()时，执行顺序是有变化的，稍不注意就会被带入坑中,</p><p>在使用async的方法中，在await之前的setState方法调用都是异步来执行的，但是在await之后，使用的setState方法就变成了同步执行的了，一张图很容易说明问题：</p><p><img src="/react/dailyInfo/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD.png" alt="异步加载"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理返回键控制</title>
      <link href="/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E6%8E%A7%E5%88%B6%E8%BF%94%E5%9B%9E%E9%94%AE/"/>
      <url>/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E6%8E%A7%E5%88%B6%E8%BF%94%E5%9B%9E%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="使用pushState-点击浏览器后退按钮-chrome-不会触发popstate事件分析"><a href="#使用pushState-点击浏览器后退按钮-chrome-不会触发popstate事件分析" class="headerlink" title="使用pushState,点击浏览器后退按钮 chrome 不会触发popstate事件分析"></a>使用pushState,点击浏览器后退按钮 chrome 不会触发popstate事件分析</h3><h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><p>在移动端开发有，一些业务场景是禁止返回到上一个页面，所以需要实现次功能， 比如：支付完成界面，防止重复提交或支付</p><h3 id="通常实现代码实现方式"><a href="#通常实现代码实现方式" class="headerlink" title="通常实现代码实现方式"></a>通常实现代码实现方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止页面后退</span></span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">URL</span>);</span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">URL</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>在实际操作中会发现，如果进入页面后没有任何人为交互操作行为的话，是不会触发 popstate 事件的，在chrome浏览器中只有手动在页面中进行交互操作（点击元素、滑动页面都算）后再点击浏览器的后退按钮才能触发popstate 事件。</p><p>但是Safari浏览器缺没有这个问题。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>没有交互操作时，通过js返回方法触发(history.go(-1)、history.back())，popstate 事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止页面后退</span></span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">URL</span>);</span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">URL</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>查阅一些资料，发现这是 chrome浏览器 为了提高用户体验，为了防止流氓网站禁止用户执行回退操作，把用户困在当前网站，专门做的一个功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 分布式锁</title>
      <link href="/redis/redisLock/"/>
      <url>/redis/redisLock/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目开发使用eggjs开发项目，在多个实例上运行的时候，同一个定时任务，可能是会多次调用，造成跑出来的数据错乱。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我们采用比较简单的方式通过redis锁实现分布式锁：</p><ol><li>在执行job之前，先创建一个redis锁</li><li>job执行完成之后，再将redis解锁</li></ol><h2 id="通过-Redlock-插件实现"><a href="#通过-Redlock-插件实现" class="headerlink" title="通过 Redlock 插件实现"></a>通过 Redlock 插件实现</h2><p>Redlock 在 Redis 单实例或多实例中提供了强有力的保障，本身具备容错能力，它会从 N 个实例使用相同的 key、随机值尝试 set key value [EX seconds] [PX milliseconds] [NX|XX] 命令去获取锁，在有效时间内至少 N/2+1 个 Redis 实例取到锁，此时就认为取锁成功，否则取锁失败，失败情况下客户端应该在所有的 Redis 实例上进行解锁。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>redislock 支持多实例</li><li>为防止死锁在创建锁的时，同时一个超时时间</li><li>操作起来比较方便</li></ul><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add redlock@<span class="number">4.2</span><span class="number">.0</span></span><br><span class="line">yarn add @types/redlock</span><br><span class="line">yarn add ioredis</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们可以封装一个redislock工具，然后再项目启动的时候，初始化一次，然后挂在到全局的上，方便直接调用，以 eggjs 为例介绍，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redislock.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RedLock</span> = <span class="built_in">require</span>(<span class="string">&#x27;redlock&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Redis</span> = <span class="built_in">require</span>(<span class="string">&#x27;ioredis&#x27;</span>);</span><br><span class="line"><span class="comment">// 导入ts类型</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Redlock</span> = <span class="built_in">require</span>(<span class="string">&#x27;redlock&#x27;</span>);</span><br><span class="line"></span><br><span class="line">type <span class="title class_">LockType</span> = <span class="function">(<span class="params">key: string</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">Redlock</span>.<span class="property">Lock</span> | <span class="literal">null</span>&gt;;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">RedisType</span> &#123;</span><br><span class="line">  <span class="attr">host</span>: string;</span><br><span class="line">  <span class="attr">password</span>: string;</span><br><span class="line">  <span class="attr">port</span>: number;</span><br><span class="line">  <span class="attr">db</span>: number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis集群实例信息</span></span><br><span class="line"><span class="keyword">const</span> redisList = [&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;10.1.1.1&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">6379</span>,</span><br><span class="line">  <span class="attr">db</span>: <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;10.1.1.1&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">6379</span>,</span><br><span class="line">  <span class="attr">db</span>: <span class="number">0</span>,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// redis 可以值前缀</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REDIS_KEY</span> = <span class="string">&#x27;JOB_LOCKER&#x27;</span>;</span><br><span class="line"><span class="comment">// 防止死锁，设置超时时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REDIS_TIMEOUT</span> = <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redislock</span> &#123;</span><br><span class="line">  <span class="attr">redlock</span>: <span class="title class_">Redlock</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> clientList = redisList.<span class="title function_">map</span>(<span class="function">(<span class="params">item: RedisType</span>) =&gt;</span> (<span class="keyword">new</span> <span class="title class_">Redis</span>(item)));</span><br><span class="line">    <span class="comment">// 实例化redlock锁，支持redis集群</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">redlock</span> = <span class="keyword">new</span> <span class="title class_">RedLock</span>(clientList, &#123;</span><br><span class="line">      <span class="comment">// 重试延迟（ms）</span></span><br><span class="line">      <span class="attr">retryDelay</span>: <span class="number">200</span>,</span><br><span class="line">      <span class="comment">// 重试次数</span></span><br><span class="line">      <span class="attr">retryCount</span>: <span class="number">5</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@sub</span> 创建redis锁方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@params</span> key 区分不同的job，采用不同的锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> job锁</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">lock</span>: <span class="title class_">LockType</span> = <span class="keyword">async</span> key =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> redislock = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redlock</span>.<span class="title function_">lock</span>(<span class="string">`<span class="subst">$&#123;REDIS_KEY&#125;</span>_<span class="subst">$&#123;key&#125;</span>`</span>, <span class="variable constant_">REDIS_TIMEOUT</span>);</span><br><span class="line">      <span class="keyword">return</span> redislock;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Redislock</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RedisLock</span> <span class="keyword">from</span> <span class="string">&#x27;.redisLock&#x27;</span>;</span><br><span class="line"><span class="comment">// 项目启动支出，初始化一个redis锁</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">didReady</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//实例化一个redis锁，挂载到app上</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">app</span>.<span class="property">redlock</span> = <span class="keyword">new</span> <span class="title class_">RedisLock</span>(<span class="variable language_">this</span>.<span class="property">app</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时处理上报的数据 redis同步到base数据</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">task</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> lock = <span class="keyword">await</span> app.<span class="property">redlock</span>.<span class="title function_">lock</span>(<span class="string">&#x27;report&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// job任务信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.<span class="title function_">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 常用操作命令</title>
      <link href="/git%E5%91%BD%E4%BB%A4/git/"/>
      <url>/git%E5%91%BD%E4%BB%A4/git/</url>
      
        <content type="html"><![CDATA[<h3 id="git-常用操作命令"><a href="#git-常用操作命令" class="headerlink" title="git 常用操作命令"></a>git 常用操作命令</h3><ul><li><p>创建秘钥：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C  <span class="string">&quot;xx@163.com&quot;</span></span><br><span class="line"><span class="comment">//然后提示输入密码和确认密码即可完成, 可以直接回车密码默认为空</span></span><br></pre></td></tr></table></figure></li><li><p>查看本机秘钥：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.<span class="property">ssh</span></span><br><span class="line"><span class="comment">// 若出现“No such file or directory”,则表示需要创建一个ssh keys。</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment">// 查看文件， 如果有id_rsa、id_rsa.pub就是已经有秘钥存在， 输入pwd可以查看文件所在路径</span></span><br><span class="line"><span class="comment">// 拷贝公钥</span></span><br><span class="line">cat id_rsa.<span class="property">pub</span>  </span><br></pre></td></tr></table></figure></li><li><p>克隆远程仓库代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@xxx.<span class="property">git</span></span><br></pre></td></tr></table></figure></li><li><p>查看提交状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>暂存 提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>查看git提交记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p>拷贝某次提交到新的分支</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick hashxxxx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看当前git远程仓库，两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure></li><li><p>移除与远程仓库的关联：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure></li><li><p>修改当前仓库地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@xxx.<span class="property">git</span></span><br></pre></td></tr></table></figure></li><li><p>本次仓库与远程仓库首次创建关联</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@xx.<span class="property">git</span></span><br></pre></td></tr></table></figure></li><li><p>本地分支重命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName  newName</span><br></pre></td></tr></table></figure></li><li><p>将重命名后的分支推送到远程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure></li><li><p>删除旧分支</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除远程分支</span></span><br><span class="line">git push --<span class="keyword">delete</span> origin oldName</span><br><span class="line"><span class="comment">// 删除本地分支</span></span><br><span class="line">git -d oldName</span><br></pre></td></tr></table></figure></li></ul><ul><li>git 回退某次提交<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会从新生成一个 commit提交    </span></span><br><span class="line">git revert &lt;commit-id&gt; </span><br></pre></td></tr></table></figure></li></ul><h6 id="clone下载分支慢，可以使用这种方式下载"><a href="#clone下载分支慢，可以使用这种方式下载" class="headerlink" title="clone下载分支慢，可以使用这种方式下载"></a>clone下载分支慢，可以使用这种方式下载</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth <span class="number">1</span> <span class="attr">https</span>:<span class="comment">//github.com/dogescript/xxxxxxx.git</span></span><br><span class="line"><span class="comment">//注意： 此种方式克隆下的代码，切换远程分支的话，需要采用下边方式</span></span><br><span class="line">git remote set-branches origin <span class="string">&#x27;remote_branch_name&#x27;</span></span><br><span class="line">git fetch --depth <span class="number">1</span> origin remote_branch_name</span><br><span class="line">git checkout remote_branch_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csrf 项目实际使用</title>
      <link href="/web%E5%AE%89%E5%85%A8/csrfDome/"/>
      <url>/web%E5%AE%89%E5%85%A8/csrfDome/</url>
      
        <content type="html"><![CDATA[<h2 id="eggjs-开启CSRF防护"><a href="#eggjs-开启CSRF防护" class="headerlink" title="eggjs 开启CSRF防护"></a>eggjs 开启CSRF防护</h2><p>eggjs官方文档： <a href="https://www.eggjs.org/zh-CN/core/security#%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81-csrf-%E7%9A%84%E9%98%B2%E8%8C%83">https://www.eggjs.org/zh-CN/core/security#%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81-csrf-%E7%9A%84%E9%98%B2%E8%8C%83</a></p><h3 id="开启CSRF配置"><a href="#开启CSRF配置" class="headerlink" title="开启CSRF配置"></a>开启CSRF配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/config.default.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">security</span>: &#123;</span><br><span class="line">    <span class="attr">csrf</span>: &#123;</span><br><span class="line">      <span class="attr">enable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开启之后，在网页访问的时候，会默认网cookie中set一个csrfToken</p><h3 id="eggjs-提供一个查询csrfToken接口"><a href="#eggjs-提供一个查询csrfToken接口" class="headerlink" title="eggjs 提供一个查询csrfToken接口"></a>eggjs 提供一个查询csrfToken接口</h3><ul><li><p>为什么要在eggjs中提供一个接口呢？<br>官方提供的文档中有这么一段描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Double</span> <span class="title class_">Cookie</span> <span class="title class_">Defense</span>：将 token 设置在 <span class="title class_">Cookie</span> 中，在提交（<span class="variable constant_">POST</span>、<span class="variable constant_">PUT</span>、<span class="variable constant_">PATCH</span>、<span class="variable constant_">DELETE</span> 等）请求时提交 <span class="title class_">Cookie</span>，并通过 header 或者 body 带上 <span class="title class_">Cookie</span> 中的 token，服务端进行对比校验。</span><br></pre></td></tr></table></figure><p>客户端我们需要的header中和body中也需要传输一下这个csrfToken的信息，但是为了安全起见，项目中所有的cookie都需要是httponly，所以的客户端就读取不到这个cookie，就需要在egg中加一个接口去返回这个token。<br>需要注意的是，这个查询csrfToken需要放置在界面渲染之后，到再开始渲染界面，防止异步操作引起失败。</p></li><li><p>开启一个新的接口</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先我们采用的方案，在一个会话固定采用一个token，用户退出或者切换的时候，更换薪token</span></span><br><span class="line"><span class="comment"> * 1. 首先从请求的cookie中获取，如果浏览器的cookie中如果有CSRFToken的话，不会从新生成</span></span><br><span class="line"><span class="comment"> * 2. 如果请求的cookie中不包含csrfToken的话，此时egg会在response中返回一个setCookie，其中就包含了csrfToken，可以从这里边获取</span></span><br><span class="line"><span class="comment"> * 3. 如果都没有的胡啊，表示没有开启，置空即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">getToken</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> cookie = ctx.<span class="property">header</span>?.<span class="property">cookie</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> csrfToken = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (cookie) &#123;</span><br><span class="line">    csrfToken = <span class="title function_">getCookie</span>(cookie, <span class="string">&#x27;csrfToken&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!csrfToken) &#123;</span><br><span class="line">    <span class="keyword">const</span> setCookie = ctx.<span class="property">response</span>?.<span class="property">header</span>?.[<span class="string">&#x27;set-cookie&#x27;</span>] <span class="keyword">as</span> [] || [<span class="string">&#x27;&#x27;</span>];</span><br><span class="line">    <span class="keyword">const</span> cookiesInfo = setCookie.<span class="title function_">join</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    csrfToken = <span class="title function_">getCookie</span>(cookiesInfo, <span class="string">&#x27;csrfToken&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    csrfToken</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析cookie信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">cookies, objName</span>) &#123;<span class="comment">// 获取指定名称的cookie的值</span></span><br><span class="line">  <span class="keyword">const</span> arrStr = cookies.<span class="title function_">split</span>(<span class="string">&quot;; &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrStr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = arrStr[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp[<span class="number">0</span>] === objName) <span class="keyword">return</span> <span class="built_in">unescape</span>(temp[<span class="number">1</span>]);  <span class="comment">// 解码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>client 部分</li></ul><p>增加请求，将返回的token，存储到sessionStorge或者直接挂在window上即可</p><p>在请求拦截中header中统一增加请求头： x-csrf-token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">Accept</span> = <span class="string">&#x27;application/json&#x27;</span>;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;x-csrf-token&#x27;</span>] = <span class="variable language_">window</span>.<span class="property">csrfToken</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    error &amp;&amp; message.<span class="title function_">error</span>(error.<span class="property">msg</span> || error.<span class="property">code</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>最后注意在退出登录或者切换用户的时候，需要手动刷新csrfToken，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// egg中刷新csrfToken的方式</span></span><br><span class="line"><span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 调用 rotateCsrfSecret 刷新用户的 CSRF token</span></span><br><span class="line">  ctx.<span class="title function_">rotateCsrfSecret</span>();</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就可以完成eggjs最基本的一个CSRF防御，如果还不能满足需求的话，可以参考正文之前提供的，eggjs文档。</p><h2 id="koa中开启CSRF防护"><a href="#koa中开启CSRF防护" class="headerlink" title="koa中开启CSRF防护"></a>koa中开启CSRF防护</h2><h3 id="插件引入"><a href="#插件引入" class="headerlink" title="插件引入"></a>插件引入</h3><p>在koa中没有想egg中直接提供的一套方案，koa中csrf防护需要借助中间件来完成，我们这里采用的是:koa-csrf</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add koa-scrf</span><br></pre></td></tr></table></figure><h3 id="中间件使用"><a href="#中间件使用" class="headerlink" title="中间件使用"></a>中间件使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CSRF</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-csrf&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入CSRF信息,默认会自动网cookie中set一个csrfToken</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_app</span>.<span class="title function_">use</span>(<span class="keyword">new</span> <span class="title function_">CSRF</span>(&#123;</span><br><span class="line">  <span class="attr">invalidTokenMessage</span>: <span class="string">&#x27;Invalid CSRF token&#x27;</span>,</span><br><span class="line">  <span class="attr">invalidTokenStatusCode</span>: <span class="number">403</span>,</span><br><span class="line">  <span class="attr">excludedMethods</span>: [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;OPTIONS&#x27;</span>],</span><br><span class="line">  <span class="attr">disableQuery</span>: <span class="literal">false</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li>开启一个新的接口， 在进入系统之前获取一下接口获取一下token</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取token，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/getToken&#x27;</span>, <span class="title function_">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">csrfToken</span>: ctx.<span class="property">csrf</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>client 部分 跟eggjs以往csrf赛一个即可</li></ul><p>增加请求，将返回的token，存储到sessionStorge或者直接挂在window上即可</p><p>在请求拦截中header中统一增加请求头： x-csrf-token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">Accept</span> = <span class="string">&#x27;application/json&#x27;</span>;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;x-csrf-token&#x27;</span>] = <span class="variable language_">window</span>.<span class="property">csrfToken</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    error &amp;&amp; message.<span class="title function_">error</span>(error.<span class="property">msg</span> || error.<span class="property">code</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>更新token<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在入口处将 将值设置为空</span></span><br><span class="line">ctx.<span class="property">session</span>.<span class="property">secret</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> web 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF 防攻击策略</title>
      <link href="/web%E5%AE%89%E5%85%A8/csrf/"/>
      <url>/web%E5%AE%89%E5%85%A8/csrf/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是CSRF？"><a href="#什么是CSRF？" class="headerlink" title="什么是CSRF？"></a>什么是CSRF？</h3><p>CSRF全称：Cross—Site Request Forgery，中文名称：跨站请求伪造有，也被成为XRCF<br>一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p><h3 id="攻击原理和过程"><a href="#攻击原理和过程" class="headerlink" title="攻击原理和过程"></a>攻击原理和过程</h3><p><img src="/web%E5%AE%89%E5%85%A8/csrf/csrf%E5%8E%9F%E7%90%86.jpeg" alt="csrf原理"></p><ol><li>用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol><span id="more"></span><h3 id="CSRF-漏洞检测"><a href="#CSRF-漏洞检测" class="headerlink" title="CSRF 漏洞检测"></a>CSRF 漏洞检测</h3><ul><li>抓取正常的请求数据包，去掉referer字段之后，看提交请求是否仍然有效;</li><li>也可以使用一些工具进行检测如：CSRFTester，CSRF Request Builder等。</li></ul><h3 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h3><ul><li><p>验证请求http中的referer<br>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。<br>在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory%EF%BC%8C%E7%94%A8%E6%88%B7%E5%BF%85%E9%A1%BB%E5%85%88%E7%99%BB%E9%99%86">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。<br>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。<br>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。<br>事实上，目前已经有一些方法可以篡改 Referer 值，即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p></li><li><p>请求中增加token</p></li></ul><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。<br>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="”hidden”" name="”csrftoken”" value="”tokenvalue”/">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。<br>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><ul><li>HTTP请求头中自定义属性，并进行验证</li></ul><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。<br>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40482816/article/details/114301717">https://blog.csdn.net/weixin_40482816/article/details/114301717</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx config</title>
      <link href="/nginx/nginxConfig/"/>
      <url>/nginx/nginxConfig/</url>
      
        <content type="html"><![CDATA[<h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx  配置"></a>nginx  配置</h3><h4 id="express"><a href="#express" class="headerlink" title="express"></a>express</h4><ul><li>nginx缓存功能<br>nginx通过配置，可以告知浏览器，返回数量的有效时间，浏览器可以根据数据的有效时间，确定是否应该到服务器请求，如果数据没有超过有效期，就使用浏览器缓存的数据。<br>优点：可以让用户快速获取使用数据，减少带宽压力<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#缓存图片文件</span><br><span class="line">&#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    location ~ \.(jepg|jpg|png)$ &#123;</span><br><span class="line">      # 1<span class="attr">d</span>: 一天  1<span class="attr">h</span>: <span class="number">1</span>小时 </span><br><span class="line">      express 1<span class="attr">d</span>:</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4>压缩资源通过网络发送的大小就更加节省资源，带宽展示变小。启用压缩机制，为了能够快速访问到资源。<br>web服务器进行压缩，浏览器需要进行解压缩操作，目前市场上大部分浏览器式支持gzip压缩的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  keepalive-timeout <span class="number">60</span>;</span><br><span class="line">  # 开启gzip</span><br><span class="line">  gzip on;</span><br><span class="line"></span><br><span class="line">  # 启用gzip压缩的最小文件；小于设置值的文件将不会被压缩</span><br><span class="line">  gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">  # gzip 压缩级别 <span class="number">1</span>-<span class="number">10</span> </span><br><span class="line">  gzip_comp_level <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  # 进行压缩的文件类型。</span><br><span class="line">  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line"></span><br><span class="line">  # 是否在http header中添加<span class="title class_">Vary</span>: <span class="title class_">Accept</span>-<span class="title class_">Encoding</span>，建议开启</span><br><span class="line">  gzip_vary on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nginx学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载字节流文件</title>
      <link href="/download/blob/"/>
      <url>/download/blob/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>上篇整理了附件下载，所以就像整理一下字节流格式的文件下载都整哪些方式</p><p>参考： <a href="https://juejin.cn/post/6989413354628448264#heading-6">https://juejin.cn/post/6989413354628448264#heading-6</a></p><h3 id="为什么要使用字节流的方式下载文件"><a href="#为什么要使用字节流的方式下载文件" class="headerlink" title="为什么要使用字节流的方式下载文件"></a>为什么要使用字节流的方式下载文件</h3><ul><li>加密<br>直接通过地址下载是没有办法进行加密的，但是通过字节流的话，可以对每一个byte或者是一些其他手段进行编码，客户端封装一个解码的类就好。</li><li>记录<br>服务器难免会有一些需求，哪个用户都下载了哪些资源，哪些玩家都做了哪些事情等等。。。如果没有get或者post请求去下载或者访问的话，服务器很难做到对数据进行记录。</li><li>批量获取<br>在做应用或者是游戏的时候，难免会批量的获取一些资源，将筛选条件发送给服务器，服务器整合资源，用一个流将所有文件和到一起发送，客户端在以相应的规则拆分字节流，存储资源。既方便记录，也方便客户端分辨资源。</li></ul><h3 id="下载处理方式"><a href="#下载处理方式" class="headerlink" title="下载处理方式"></a>下载处理方式</h3><p>字节流下载，就跟我们的正常接口请求一样，只不过是通过接口请求将子接口下载到浏览器，然后浏览器再将其转化为文件。</p><p>根据项目实例来战来解析字节流下载的一下相关处理方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params">url, data = &#123;&#125;, method = <span class="string">&#x27;get&#x27;</span>, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="comment">// 将返回类型设置为 arraybuffer类型</span></span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;arraybuffer&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> requestMethod;</span><br><span class="line">  <span class="keyword">if</span> (method.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">    requestMethod = axios.<span class="title function_">get</span>(url, options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    requestMethod = axios.<span class="title function_">post</span>(url, data, options);</span><br><span class="line">  &#125;</span><br><span class="line">  requestMethod.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回码 status不等于200的时候返回报错</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">status</span> != <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 将arraybuffer数据转为 json</span></span><br><span class="line">      <span class="keyword">const</span> errData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">String</span>.<span class="property">fromCharCode</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(response.<span class="property">data</span>)));</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: errData.<span class="property">message</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取请求头中返回的文件名字</span></span><br><span class="line">    <span class="keyword">let</span> fileName = <span class="variable language_">window</span>.<span class="built_in">decodeURI</span>(</span><br><span class="line">      response.<span class="property">headers</span>[<span class="string">&#x27;content-disposition&#x27;</span>] &amp;&amp; response.<span class="property">headers</span>[<span class="string">&#x27;content-disposition&#x27;</span>].<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (fileName === <span class="string">&#x27;undefined&#x27;</span> || fileName === <span class="literal">null</span> || fileName === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: response.<span class="property">headers</span>.<span class="property">msg</span> || <span class="string">&#x27;未获取到文件名&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="title function_">startsWith</span>(<span class="string">&#x27;&quot;&#x27;</span>) &amp;&amp; fileName.<span class="title function_">endsWith</span>(<span class="string">&#x27;&quot;&#x27;</span>)) &#123;</span><br><span class="line">      fileName = fileName.<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saveFile = <span class="function">(<span class="params">response, fileName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Blob转化的文件类型，如果格式不匹配的话，转文件的话会乱码，取文件名字的后缀判断即可</span></span><br><span class="line">  <span class="keyword">const</span> mimeTypeMapping = &#123;</span><br><span class="line">    <span class="attr">xlsx</span>: <span class="string">&#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="attr">xls</span>: <span class="string">&#x27;application/vnd.ms-excel;charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="attr">docx</span>: <span class="string">&#x27;application/vnd.openxmlformats-officedocument.wordprocessingml.document;charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="attr">doc</span>: <span class="string">&#x27;application/msword;charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="attr">pdf</span>: <span class="string">&#x27;application/pdf;charset=UTF-8&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> fileType = fileName.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件转化为链接</span></span><br><span class="line">  link.<span class="property">href</span> = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Blob</span>([response.<span class="property">data</span>], &#123;</span><br><span class="line">      <span class="attr">type</span>: mimeTypeMapping[fileType],</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">  link.<span class="property">download</span> = fileName;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">  link.<span class="title function_">click</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h3><ul><li>多次循环调用接口下载即可</li><li>可以让server端将文件字节流放在一起返回，然后client根据约定的分割格式，去拆分并形成不同的文件。（未尝试过）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/nginx/nginx/"/>
      <url>/nginx/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="nginx-入门"><a href="#nginx-入门" class="headerlink" title="nginx 入门"></a>nginx 入门</h2><h4 id="nginx-特点"><a href="#nginx-特点" class="headerlink" title="nginx 特点"></a>nginx 特点</h4><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，<br>此时代理服务器对外就表现为一个服务器。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>单个服务器解决不了的问题，我们增加服务器数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以吧动态页面和静态界面由不同的服务器来解析，加快服务器的解析速度，降低原来单个服务器的压力</p><span id="more"></span><h3 id="nginx-安装–linux为例"><a href="#nginx-安装–linux为例" class="headerlink" title="nginx 安装–linux为例"></a>nginx 安装–linux为例</h3><ul><li>安装地址： <a href="http://nginx.org/">http://nginx.org</a></li></ul><p>依赖：</p><ul><li>pcre</li><li>zlib zlib-devel</li><li>gcc-c++</li><li>libtool</li><li>openssl openssl-devel</li></ul><p>将依赖安装到src目录下</p><h4 id="安装pcre依赖，"><a href="#安装pcre依赖，" class="headerlink" title="安装pcre依赖，"></a>安装pcre依赖，</h4><ul><li>把安装的文件放到linux系统中 直接拖过去即可</li><li>解压文件  tar -xvf ***(压缩包文件)</li><li>进入解压之后目录，执行 ./configure</li><li>使用： make &amp;&amp; make install    文件做编译，并安装</li><li>查看配置文件：pcre-config –version</li></ul><h4 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>mac电脑安装： <a href="https://www.jianshu.com/p/4f433d219ab7">https://www.jianshu.com/p/4f433d219ab7</a></p><ul><li>把安装的文件放到linux系统中 直接拖过去即可</li><li>解压文件  tar -xvf ***(压缩包文件)</li><li>进入解压之后目录，执行 ./configure</li><li>使用： make &amp;&amp; make install    文件做编译，并安装</li><li>安装成功之后 /usr 下会多出来一个文件夹local/nginx，在nginx中有sbin有启动脚本</li></ul><h3 id="nginx-启动"><a href="#nginx-启动" class="headerlink" title="nginx 启动"></a>nginx 启动</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>增加端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看防火墙开放端口号</span></span><br><span class="line">filewall-cmd --list-all</span><br><span class="line"><span class="comment">// 设置开放端口号</span></span><br><span class="line">sudo firewall-cmd --add-port-port=<span class="number">8001</span>/tcp --permanent</span><br><span class="line"><span class="comment">// 设置完端口号中重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h3><p>使用nginx操作命令必须进入到nginx的目录中: /usr/local/nginx/sbin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看版本号</span></span><br><span class="line">./nginx -v</span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">./nginx </span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="comment">// 重新加载nginx</span></span><br><span class="line">./nginx -s reload</span><br><span class="line"><span class="comment">// 查看所有nginx 命令</span></span><br><span class="line">./nginx -h</span><br><span class="line"><span class="comment">// 查看进程</span></span><br><span class="line">pm -ef | grep nginx</span><br></pre></td></tr></table></figure><h3 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h3><ul><li>nginx 配置文件在什么位置<br>/usr/local/nginx/conf/nginx.conf</li><li>nginx 配置文件<ul><li>全局块<br>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令<br>主要包括配置运行的nginx服务器的用户（组），允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line"># nginx 服务器处理的并发数量，值越发处理并发量也越大</span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line">#error_log  logs/error.<span class="property">log</span>;</span><br><span class="line">#error_log  logs/error.<span class="property">log</span>  notice;</span><br><span class="line">#error_log  logs/error.<span class="property">log</span>  info;</span><br><span class="line">#pid        logs/nginx.<span class="property">pid</span>;</span><br></pre></td></tr></table></figure></li><li>events块<br>涉及的质量主要影响nginx与用户的网络链接， 此部分内容对nginx的性能影响较大，在实际中应该灵活配置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">  <span class="comment">// 支持的最大连接数</span></span><br><span class="line">  worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>http块: 包含 http 全局块，server块<br>这里是nginx配置中最频繁的部分，代理。缓存和日志定义等绝大多数功能和第三方模块都配置再这里<ul><li>http全局块: 配置的指令包括文件引入，mime-type定义、日志自定义、连接超时时间、单链接请求书上限等<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       mime.<span class="property">types</span>;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">  #log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">  #                  <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">  #                  <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line">  #access_log  logs/access.<span class="property">log</span>  main;</span><br><span class="line">  sendfile        on;</span><br><span class="line">  #tcp_nopush     on;</span><br><span class="line">  #keepalive_timeout  <span class="number">0</span>;</span><br><span class="line">  keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">  #gzip  on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>server块: 和虚拟主机有密切关系，包含，全局server和localtion<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    #nginx 目前监听的端口号</span><br><span class="line">    listen       <span class="number">8080</span>;</span><br><span class="line">    # 主机名称</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    # 请求拦截块 </span><br><span class="line">    location / &#123;</span><br><span class="line">      root   html;</span><br><span class="line">      index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="nginx-配置实例-—-反向代理"><a href="#nginx-配置实例-—-反向代理" class="headerlink" title="nginx 配置实例 — 反向代理"></a>nginx 配置实例 — 反向代理</h4><ul><li>实现效果</li></ul><ul><li>打开浏览器，在浏览器中输入地址：<a href="http://www.123.com/">www.123.com</a> 跳转到Linux系统的baidu.com主页中 </li></ul><ul><li><p>准备 —– linux 中安装tomact</p><ul><li>安装openJDK -java运行环境</li><li>把安装的文件放到linux系统中 直接拖过去即可</li><li>解压文件  tar -xvf ***(压缩包文件)</li><li>进入解压之后的文件中,然后进入/bin 文件下</li><li>.startup.sh  启动 tomact</li><li>进入 cd logs</li><li>查看启动日志 : tail -f catalina.out</li></ul></li><li><p>对外开放8080端口号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置开放端口号</span></span><br><span class="line">sudo firewall-cmd --add-port-port=<span class="number">8080</span>/tcp --permanent</span><br><span class="line"><span class="comment">// 设置完端口号中重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>实践</p></li></ul><ol><li>修改hosts文件，把 127.0.0.1 <a href="http://www.123.com/">www.123.com</a> </li><li>nginx进行请求转发 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  <span class="comment">// 当访问服务访问的域名，指向百度</span></span><br><span class="line"> <span class="comment">// 不会修改访问url只会将原来的域名改为此路径</span></span><br><span class="line">  proxy_pass  <span class="attr">https</span>:<span class="comment">//www.baidu.com</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="nginx-配置实例-—-负载均衡"><a href="#nginx-配置实例-—-负载均衡" class="headerlink" title="nginx 配置实例 — 负载均衡"></a>nginx 配置实例 — 负载均衡</h4><p>nginx分配服务器策略</p><ul><li><p>轮询（默认）： 每个请求按照时间顺序逐一分配到不用的后端服务器，如果后端服务器domn掉，能自动剔除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负载均衡名字</span></span><br><span class="line">stream myServer &#123;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8080</span>;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8081</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  proxy_pass  <span class="attr">https</span>:<span class="comment">//myServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>weight ： 代表权重默认为1 ，权重越高被分配的客户端就越多,按比例分配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负载均衡名字</span></span><br><span class="line">stream myServer &#123;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8080</span> weight=<span class="number">5</span>;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8081</span> weight=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  proxy_pass  <span class="attr">https</span>:<span class="comment">//myServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash：每个请求按照访问ip的hash结果分配，这样每个方可固定访问一个后端服务器（服务器设置session时，会用到）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负载均衡名字</span></span><br><span class="line">stream myServer &#123;</span><br><span class="line">  ip_hash</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8080</span>;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8081</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  proxy_pass  <span class="attr">https</span>:<span class="comment">//myServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair(第三方)： 按照后端服务器的响应时间来分配请求，响应时间短的有限分配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负载均衡名字</span></span><br><span class="line">stream myServer &#123;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8080</span>;</span><br><span class="line">  server <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">8081</span>;</span><br><span class="line">  fair;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  proxy_pass  <span class="attr">https</span>:<span class="comment">//myServer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="nginx-配置实例—-动静分离"><a href="#nginx-配置实例—-动静分离" class="headerlink" title="nginx 配置实例— 动静分离"></a>nginx 配置实例— 动静分离</h4><p>nginx动静分离简单的来说就是把动态和静态请求分开，不能理解成制单成的吧动态界面和静态界面物理分离，严格意义上来说应该是动态请求和静态请求分离开，可以理解成nginx处理静态请求，tacmat来处理请求</p><p>在服务创建data文件夹，在data中分别创建 www和image文件夹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问： http://***/www/index.html 可以直接访问到data下的www文件夹中</span></span><br><span class="line">location /www/ &#123;</span><br><span class="line">  root /data/;</span><br><span class="line">  index index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问： http://***/image/01.jpg 可以直接访问到data下的image</span></span><br><span class="line">location /image/ &#123;</span><br><span class="line">  root /data/;</span><br><span class="line">  <span class="comment">// 列出当前文件夹中的目录内容</span></span><br><span class="line">  autoindex on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nginx-高可用"><a href="#nginx-高可用" class="headerlink" title="nginx 高可用"></a>nginx 高可用</h4><ul><li>服务器上安装keepalived<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">yum install keepalived -y</span><br><span class="line"><span class="comment">// 查看是否安装</span></span><br><span class="line">rpm -q -a keepalived</span><br></pre></td></tr></table></figure></li><li>在etc中生成一个目录 keepalived, 有一个文件keepalived.conf</li></ul><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本文件 检测服务是否可用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_instanve <span class="variable constant_">VI_1</span> &#123;</span><br><span class="line">  state <span class="variable constant_">MASTER</span>   # <span class="variable constant_">MATER</span> 主服务器  <span class="variable constant_">BACKUP</span> 备份服务器</span><br><span class="line">  interface ens22 # 网卡</span><br><span class="line">  virtual_router_id <span class="number">51</span> # 主、备服务器必须相同</span><br><span class="line">  priority <span class="number">100</span> # 主、备机取不同的优先级，主机值较大。，备份机较小</span><br><span class="line">  advert_int <span class="number">1</span> </span><br><span class="line">  authentication &#123;</span><br><span class="line">    auth_type <span class="variable constant_">PASS</span></span><br><span class="line">    auth_pass <span class="number">1111</span></span><br><span class="line">  &#125;</span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    <span class="number">192.168</span><span class="number">.17</span><span class="number">.50</span> # <span class="variable constant_">VRRP</span> H虚拟主机</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nginx-原理解析"><a href="#nginx-原理解析" class="headerlink" title="nginx 原理解析"></a>nginx 原理解析</h3><p>设置worker数量： 一个worker可以吧一个cpu发挥到极致，worker数跟cpu数量向东</p><ul><li>连接数 worker-connection<ul><li>一个请求，占用多个worker几个连接数：  2个或者4个 静态资源：2  反向代理链接java：4</li><li>nginx 有一个master，有四个worker，每个worker支持最大的连接数据1024，支持最大并发数是多少？<ul><li>静态访问 worker_connection*worker_processes/2</li><li>http 反向代理 worker_connection*worker_processes/4</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nginx学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx location</title>
      <link href="/nginx/nginxLocation/"/>
      <url>/nginx/nginxLocation/</url>
      
        <content type="html"><![CDATA[<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>语法规则： location [=|<del>|</del>*|^~] /uri/ { … }</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> =  开头表示精确匹配</span><br><span class="line"><span class="number">2.</span> ^~  开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/<span class="keyword">static</span>/<span class="number">20</span>%<span class="regexp">/aa，可以被规则^~ /</span><span class="keyword">static</span>/ /aa匹配到（注意是空格）。</span><br><span class="line"><span class="number">3.</span> ~  开头表示区分大小写的正则匹配</span><br><span class="line"><span class="number">4.</span> ~* 开头表示不区分大小写的正则匹配</span><br><span class="line"><span class="number">5.</span> !~ 区分大小写不匹配的正则</span><br><span class="line"><span class="number">6.</span> !~* 不区分大小写不匹配的正则</span><br><span class="line"><span class="number">7.</span> /  通用匹配，任何请求都会匹配到。</span><br><span class="line"></span><br><span class="line">多个location配置的情况下匹配顺序为：</span><br><span class="line">首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">  规则A</span><br><span class="line">&#125;</span><br><span class="line">location = /login &#123;</span><br><span class="line">  规则B</span><br><span class="line">&#125;</span><br><span class="line">location ^~ <span class="regexp">/static/</span> &#123;</span><br><span class="line">  规则C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">  规则D</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.<span class="property">png$</span> &#123;</span><br><span class="line">  规则E</span><br><span class="line">&#125;</span><br><span class="line">location !~ \.<span class="property">xhtml$</span> &#123;</span><br><span class="line">  规则F</span><br><span class="line">&#125;</span><br><span class="line">location !~* \.<span class="property">xhtml$</span> &#123;</span><br><span class="line">  规则G</span><br><span class="line">&#125;</span><br><span class="line">location /&#123;</span><br><span class="line">  规则<span class="title class_">Hs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么产生的效果如下：<br>访问根目录/， 比如<a href="http://localhost/">http://localhost/</a> 将匹配规则A<br>访问 <a href="http://localhost/login">http://localhost/login</a> 将匹配规则B，<a href="http://localhost/register">http://localhost/register</a> 则匹配规则H<br>访问 <a href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则C<br>访问 <a href="http://localhost/a.gif">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a href="http://localhost/static/c.png">http://localhost/static/c.png</a> 则优先匹配到 规则C<br>访问 <a href="http://localhost/a.PNG">http://localhost/a.PNG</a> 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。<br>访问 <a href="http://localhost/a.xhtml">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a href="http://localhost/a.XHTML%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99G%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E3%80%82%E8%A7%84%E5%88%99F%EF%BC%8C%E8%A7%84%E5%88%99G%E5%B1%9E%E4%BA%8E%E6%8E%92%E9%99%A4%E6%B3%95%EF%BC%8C%E7%AC%A6%E5%90%88%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%83%B3%E6%83%B3%E7%9C%8B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E3%80%82">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a><br>访问 <a href="http://localhost/category/id/1111">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。<br>所以实际使用中，通常至少有三个匹配规则定义，如下：<br>s</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line"></span><br><span class="line">location = / &#123;</span><br><span class="line">  <span class="comment">// 不会修改访问url只会将原来的域名改为此路径</span></span><br><span class="line">    proxy_pass <span class="attr">http</span>:<span class="comment">//tomcat:8080/index</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line"></span><br><span class="line">location ^~ <span class="regexp">/static/</span> &#123;</span><br><span class="line">    root /webroot/<span class="keyword">static</span>/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.<span class="property">php</span>,.<span class="property">jsp</span>后缀的情况很少了</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass <span class="attr">http</span>:<span class="comment">//tomcat:8080/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nginx学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附件（url链接）下载</title>
      <link href="/download/attachment/"/>
      <url>/download/attachment/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>项目中，客户有个需求，需要在查询日期中的文件，由于文件可能会有多个，所需要多处理一下多文件同时下载的情况，</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>首先多文件下载的话，使用循环同时触发下载多个文件,首先想到常用的几种方式，然后通过循环调用，确认是否可以正常下载</p><p>常用的自动触发下载的集中方式</p><ul><li>window.open()  直接下载</li><li>创建a标签下载 </li><li>创建iframe下载 </li></ul><h4 id="首先使用window-open尝试"><a href="#首先使用window-open尝试" class="headerlink" title="首先使用window.open尝试"></a>首先使用window.open尝试</h4><p>window.open(url, type)支持两个参数，</p><ul><li>url: 下载文件的目标路径，</li><li>type: 支持两种类型：<ul><li>_blank: 新开发一个窗口下载，下载的时候新窗口会关闭，界面会闪一下</li><li>_self: 直接在当前窗口下载</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[url,url1,url2,url3,url4].<span class="title function_">forEach</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">open</span>(url, <span class="string">&#x27;_self&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方式下载，会被认为恶意操作，只会下载最后一个请求<br><img src="/download/attachment/download1.png" alt="download"></p><span id="more"></span><h4 id="通过a标签下载-—-查资料说跨域文件批量下载，多个文件被cancel下载（待考证）"><a href="#通过a标签下载-—-查资料说跨域文件批量下载，多个文件被cancel下载（待考证）" class="headerlink" title="通过a标签下载   —- 查资料说跨域文件批量下载，多个文件被cancel下载（待考证）"></a>通过a标签下载   —- 查资料说跨域文件批量下载，多个文件被cancel下载（待考证）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[downloadUrl,downloadUrl1,downloadUrl2,downloadUrl3,downloadUrl4].<span class="title function_">forEach</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  a.<span class="property">href</span> = url;</span><br><span class="line">  a.<span class="title function_">click</span>();</span><br><span class="line">  a.<span class="title function_">remove</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/download/attachment/download2.png" alt="download"></p><h4 id="通过iframe-创建下载标签-也可以正常下载"><a href="#通过iframe-创建下载标签-也可以正常下载" class="headerlink" title="通过iframe 创建下载标签 也可以正常下载"></a>通过iframe 创建下载标签 也可以正常下载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[downloadUrl,downloadUrl1,downloadUrl2,downloadUrl3,downloadUrl4].<span class="title function_">forEach</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line"> iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"> iframe.<span class="property">style</span>.<span class="property">height</span> = <span class="number">0</span>;</span><br><span class="line"> iframe.<span class="property">src</span> = url;</span><br><span class="line"> <span class="comment">// 与前两种方式不同，iframe需要挂载到页面上才能触发请求</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   iframe.<span class="title function_">remove</span>();</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><img src="/download/attachment/download2.png" alt="download"></p><p>注意： </p><ul><li>Transfer-Encoding: chunked  文件过大的话，可以通过response header中设置这个参数设置分片下载</li><li>批量下载的话，浏览器会出现这个提示，需要允许浏览器可以批量下载文件，否则只会下载第一个文件<br><img src="/download/attachment/download3.png" alt="download"></li></ul><h3 id="实现附件下载"><a href="#实现附件下载" class="headerlink" title="实现附件下载"></a>实现附件下载</h3><p>在服务端下载的场景中，附件形式下载是一种比较常见的场景。在该场景下，我们通过设置 Content-Disposition 响应头来指示响应的内容以何种形式展示，是以内联（inline）的形式，还是以附件（attachment）的形式下载并保存到本地。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: inline</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: attachment</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: attachment; filename=<span class="string">&quot;mouth.png&quot;</span></span><br></pre></td></tr></table></figure><p>而在 HTTP 表单的场景下， Content-Disposition 也可以作为 multipart body 中的消息头：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: form-data</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: form-data; name=<span class="string">&quot;fieldName&quot;</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: form-data; name=<span class="string">&quot;fieldName&quot;</span>; filename=<span class="string">&quot;filename.jpg&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页打印设置</title>
      <link href="/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E7%BD%91%E9%A1%B5%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE/"/>
      <url>/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E7%BD%91%E9%A1%B5%E6%89%93%E5%8D%B0%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="遇到客户需求，需要打印网页的需求"><a href="#遇到客户需求，需要打印网页的需求" class="headerlink" title="遇到客户需求，需要打印网页的需求"></a>遇到客户需求，需要打印网页的需求</h3><p>在客户最初提出这个问题的时候，并不是太理解。因为我们界面设置的时候，没考虑过这个问题，所以使用浏览器打印的时候，显示界面宽度打印不全，并且只能打印当前浏览器宽度的内容。<br>查了一下文档内容，可以可以使用媒体查询解决此问题。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>使用媒体查询 @media print 控制打印时的css样式，从而实现内容打印，在媒体查询中可以根据自己的需求打印样式调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@media print&#123;</span><br><span class="line">    @page &#123;</span><br><span class="line">        <span class="attr">size</span>: landscape;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定制纸张旋转模式打印</span></span><br><span class="line">    <span class="comment">// @page rotated &#123;</span></span><br><span class="line">    <span class="comment">//     size: landscape;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        由于内容过长，css设置了代码设置了，height: 100%;  overflow: auto；</span></span><br><span class="line"><span class="comment">        由于在打印的时候，只能打印当前屏幕内的内容，屏幕外滚动的内容，就不能显示打印了</span></span><br><span class="line"><span class="comment">        然后通过将： height 设置为auto，让内容的高度等设置的高度，这样选择打印的时候，就可以全部展示出来了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    #root .<span class="property">ant</span>-layout &#123;</span><br><span class="line">        <span class="attr">height</span>: auto !important;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果内容过长不能在一页打印的话，可以通过设置缩放比来，来控制内容在一页展示</span></span><br><span class="line">    html &#123;</span><br><span class="line">        <span class="attr">zoom</span>: <span class="number">25</span>%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size: landscape  强制以横屏模式打印， protrait: 强制以竖向模式打印， a4: 以A4纸张模式打印</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node接入nacos</title>
      <link href="/%E5%B7%A5%E5%85%B7%E5%BA%93/node%E6%8E%A5%E5%85%A5nacos/"/>
      <url>/%E5%B7%A5%E5%85%B7%E5%BA%93/node%E6%8E%A5%E5%85%A5nacos/</url>
      
        <content type="html"><![CDATA[<h2 id="读取nacos配置文件"><a href="#读取nacos配置文件" class="headerlink" title="读取nacos配置文件"></a>读取nacos配置文件</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>为了更好、更灵活的管理项目文件，所以将项目的配置文件抽取到nacos中</li><li>为方便通过脚本控制更新，减少手动出错的概率，我们采用yml文件格式管理</li></ul><h3 id="所需插件"><a href="#所需插件" class="headerlink" title="所需插件"></a>所需插件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add nacos</span><br><span class="line">yarn add js-yaml</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ymal = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nacos配置信息可以都从node配置中获取  ---- process.env.x</span></span><br><span class="line"><span class="comment"> * 可以通过docker启动的服务，可以直接在配置的时候，注入到环境中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">// 服务器地址： nacos文件的服务器地址</span></span><br><span class="line">    <span class="attr">serverAddr</span>: process.<span class="property">env</span>.<span class="property">CONFIG_SERVER_URL</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// 命名空间：，一般是根据根据不同的环境区分</span></span><br><span class="line">    <span class="attr">namespace</span>: process.<span class="property">env</span>.<span class="property">DEPLOY_ENV</span> || <span class="string">&#x27;dev&#x27;</span>,</span><br><span class="line">    <span class="comment">// 组：配置文件所属的组（项目）</span></span><br><span class="line">    <span class="attr">group</span>: process.<span class="property">env</span>.<span class="property">NACOS_GROUP</span> || <span class="string">&#x27;project&#x27;</span>,</span><br><span class="line">    <span class="comment">// 配置文件名</span></span><br><span class="line">    <span class="attr">dataId</span>: process.<span class="property">env</span>.<span class="property">NACOS_DATA_ID</span> || <span class="string">&#x27;web.yml&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 根据namespace和 serverAddr 获取nacos对应服务和环境</span></span><br><span class="line"><span class="keyword">const</span> configClient = <span class="keyword">new</span> <span class="title class_">NacosConfigClient</span>(&#123;<span class="attr">serverAddr</span>: config.<span class="property">serverAddr</span>, <span class="attr">namespace</span>: config.<span class="property">namespace</span>&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 dataId 和 group 获取对应的配置文件, 获取配置文件许下</span></span><br><span class="line"><span class="comment"> * configClient.getConfig 是一个promise的异步方法</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">nacosRes = <span class="keyword">await</span> configClient.<span class="title function_">getConfig</span>(config.<span class="property">dataId</span>, config.<span class="property">group</span>);</span><br><span class="line"><span class="comment">// 获取nacos文件，返回的是一个字符串，将字符串转为json格式</span></span><br><span class="line"><span class="keyword">const</span> nacosConfig = ymal.<span class="title function_">load</span>(nacosRes);</span><br></pre></td></tr></table></figure><h3 id="实际项目使用时"><a href="#实际项目使用时" class="headerlink" title="实际项目使用时"></a>实际项目使用时</h3><p>一般本地开发不需要去连接nacos，只有线上的时候，本地可以调去项目内容的文件，方便修改调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getNacos.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ymal = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nacos配置信息可以都从node配置中获取  ---- process.env.x</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="comment">// 服务器地址： nacos文件的服务器地址</span></span><br><span class="line">    <span class="attr">serverAddr</span>: process.<span class="property">env</span>.<span class="property">CONFIG_SERVER_URL</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// 命名空间：，一般是根据根据不同的环境区分</span></span><br><span class="line">    <span class="attr">namespace</span>: process.<span class="property">env</span>.<span class="property">DEPLOY_ENV</span> || <span class="string">&#x27;dev&#x27;</span>,</span><br><span class="line">    <span class="comment">// 组：配置文件所属的组（项目）</span></span><br><span class="line">    <span class="attr">group</span>: process.<span class="property">env</span>.<span class="property">NACOS_GROUP</span> || <span class="string">&#x27;project&#x27;</span>,</span><br><span class="line">    <span class="comment">// 配置文件名</span></span><br><span class="line">    <span class="attr">dataId</span>: process.<span class="property">env</span>.<span class="property">NACOS_DATA_ID</span> || <span class="string">&#x27;web.yml&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getConfig</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span>  nacosRes = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="comment">// 通过启动的环境变量控制 NODE_ENV=development时，获取本地配置文件</span></span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取本地配置文件内容 process.env.ENV 控制当前环境，用于区分使用哪个环境启动</span></span><br><span class="line">            nacosRes = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">`./config.nacos.<span class="subst">$&#123; || <span class="string">&#x27;local&#x27;</span>&#125;</span>.yml`</span>), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据namespace和 serverAddr 获取nacos对应服务和环境</span></span><br><span class="line">            <span class="keyword">const</span> configClient = <span class="keyword">new</span> <span class="title class_">NacosConfigClient</span>(&#123;<span class="attr">serverAddr</span>: config.<span class="property">serverAddr</span>, <span class="attr">namespace</span>: config.<span class="property">namespace</span>&#125;);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 根据 dataId 和 group 获取对应的配置文件, 获取配置文件许下</span></span><br><span class="line"><span class="comment">             * configClient.getConfig 是一个promise的异步方法</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">            nacosRes = <span class="keyword">await</span> configClient.<span class="title function_">getConfig</span>(config.<span class="property">dataId</span>, config.<span class="property">group</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取nacos文件，返回的是一个字符串，将字符串转为json格式</span></span><br><span class="line">        <span class="keyword">const</span> nacosConfig = ymal.<span class="title function_">load</span>(nacosRes);</span><br><span class="line">        <span class="comment">// 成功之后回调</span></span><br><span class="line">        <span class="title function_">resolve</span>(nacosConfig || &#123;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = getConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先获取nacos信息，在启动服务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">getConfig</span>().<span class="title function_">then</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取nacos信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>json转yml在线地址： <a href="https://oktools.net/json2yaml">https://oktools.net/json2yaml</a><br>本地配置文件的命名参考：config.nacos.dev1.yml</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动命令</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start:dev1&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development ENV=dev1 node server&quot;</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ymal文件读取</title>
      <link href="/%E5%B7%A5%E5%85%B7%E5%BA%93/yaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
      <url>/%E5%B7%A5%E5%85%B7%E5%BA%93/yaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="ymal文件读取"><a href="#ymal文件读取" class="headerlink" title="ymal文件读取"></a>ymal文件读取</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>因为项目中配置文件放在nacos的配置文件中，从nacos配置中获取，后端使用的事yml文件，而前端用的是json文件的，并且每次修改nacos的话，都需要通过手动的修改方式去调整，而且到生产环境和测试环境的话，我们又没有权限修改，都维护到一个excel中统一由配管人员来统一修改，但是excel中的配置文件复制展示操作起来极不方便，并且还容易出问题。<br>所以现在改为通过脚本自动化修改配置，开发人员写好自动化的配置脚本之后，配管会员直接运行脚本就好了，这里就引起了一个问题，就是前端的配置文件使用的是json格式，而json格式又不支持自动化脚本修改</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可将json文件改为yml文件，node数据直接解析将yml文件服务为json对象即可实现</p><span id="more"></span><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这里采用js-ymal插件读取yml文件转为json对应</p><ul><li><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install js-yaml</span><br></pre></td></tr></table></figure></li><li><p>使用方式</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs   = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 读取项目本地的yml文件，如果是nacos的话，直接从获取到的就是fileYml</span></span><br><span class="line">  <span class="keyword">const</span> fileYml = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;web.yml&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> config = yaml.<span class="title function_">load</span>(fileYml);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h3 id="YML是什么"><a href="#YML是什么" class="headerlink" title="YML是什么"></a>YML是什么</h3><p>YAML (YAML Ain’t a Markup Language)YAML不是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。</p><h3 id="YML的优点"><a href="#YML的优点" class="headerlink" title="YML的优点"></a>YML的优点</h3><ul><li>YAML易于人们阅读。</li><li>YAML数据在编程语言之间是可移植的。</li><li>YAML匹配敏捷语言的本机数据结构。</li><li>YAML具有一致的模型来支持通用工具。</li><li>YAML支持单程处理。</li><li>YAML具有表现力和可扩展性。</li><li>YAML易于实现和使用。</li></ul><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>阮一峰老师，这里对jison文件已经介绍的很清楚了，这里就不在赘述了，查看使用请移步至<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程<a></a></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 相关</title>
      <link href="/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Hexo-%E7%9B%B8%E5%85%B3/"/>
      <url>/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Hexo-%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-生成的博客点击文章不会跳转界面，变成了直接下载"><a href="#Hexo-生成的博客点击文章不会跳转界面，变成了直接下载" class="headerlink" title="Hexo 生成的博客点击文章不会跳转界面，变成了直接下载"></a>Hexo 生成的博客点击文章不会跳转界面，变成了直接下载</h2><p>调查发现是因为修改了_config.xml（主文件夹下的设置文件，不是theme里面的）中的permalink参数，在修改中把最后一个斜杠给去掉了，重新加上之后可以点击下载了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文章的 永久链接 格式 </span></span><br><span class="line"><span class="attr">permalink</span>: :title/</span><br></pre></td></tr></table></figure><br><hr><span id="more"></span><h2 id="Hexo的文档中添加图片"><a href="#Hexo的文档中添加图片" class="headerlink" title="Hexo的文档中添加图片"></a>Hexo的文档中添加图片</h2><p>hexo 文档中添加图片的话，需要安装一下 hexo-asset-image 插件<br>将_config.yml文件中的配置文件改为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure><p>以在_posts文件中使用，在与创建的md文件的同一个文件夹下，创建一个与md同名的文件夹，然后再引入的时候，可以直接使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片默认文字](文件夹/图片)</span><br></pre></td></tr></table></figure><p>例如：<br>在myFAQ文件夹下创建一个myInfo.md文件,需要引入图片时,则：</p><ul><li>首先在myFAQ文件加载创建一个myInfo的文件夹，image.png放入文件夹中</li><li>在myInfo.md中引入：<code>![image](myInfo/image.png) </code></li></ul><h2 id="Hexo使用小技巧"><a href="#Hexo使用小技巧" class="headerlink" title="Hexo使用小技巧"></a>Hexo使用小技巧</h2><ul><li><code>&lt;!-- more --&gt;</code>： 在首页列表界面，为了能让多个文档信息展示看起来没那么乱，可以使用此标签使文档阶段，展示read more按钮</li></ul><h2 id="创建新的md文件"><a href="#创建新的md文件" class="headerlink" title="创建新的md文件"></a>创建新的md文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在__posts下创建一个 &#x27;test1.md&#x27;</span></span><br><span class="line">hexo <span class="keyword">new</span> test1</span><br><span class="line"><span class="comment">// 在__posts/工具库文件夹下创建一个 &#x27;test2&#x27;</span></span><br><span class="line">hexo <span class="keyword">new</span> page --path 工具库/test2</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来.</li></ul><h2 id="Hexo-遇到问题"><a href="#Hexo-遇到问题" class="headerlink" title="Hexo 遇到问题"></a>Hexo 遇到问题</h2><h3 id="hexo-g报错-—-line-mathALL-is-not-funciton问题解决"><a href="#hexo-g报错-—-line-mathALL-is-not-funciton问题解决" class="headerlink" title="hexo g报错  —   line.mathALL is not funciton问题解决"></a>hexo g报错  —   line.mathALL is not funciton问题解决</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误类似</span></span><br><span class="line"><span class="variable constant_">FATAL</span> &#123; <span class="attr">err</span>:</span><br><span class="line"><span class="title class_">TypeError</span>: line.<span class="property">matchAll</span> is not a <span class="keyword">function</span></span><br><span class="line">at res.<span class="property">value</span>.<span class="property">res</span>.<span class="property">value</span>.<span class="property">split</span>.<span class="property">map</span>.<span class="property">line</span> (<span class="regexp">/home/u</span>buntu/hexoblog/node_modules/hexo-util/lib/highlight.<span class="property">js</span>:<span class="number">128</span>:<span class="number">26</span>)</span><br><span class="line">at <span class="title class_">Array</span>.<span class="property">map</span> ()</span><br><span class="line">at closeTags (<span class="regexp">/home/u</span>buntu/hexoblog/node_modules/hexo-util/lib/highlight.<span class="property">js</span>:<span class="number">126</span>:<span class="number">37</span>)</span><br><span class="line">at highlight (<span class="regexp">/home/u</span>buntu/hexoblog/node_modules/hexo-util/lib/highlight.<span class="property">js</span>:<span class="number">119</span>:<span class="number">10</span>)</span><br><span class="line">at highlightUtil (<span class="regexp">/home/u</span>buntu/hexoblog/node_modules/hexo-util/lib/highlight.<span class="property">js</span>:<span class="number">23</span>:<span class="number">16</span>)</span><br><span class="line">at data.<span class="property">content</span>.<span class="property">dataContent</span>.<span class="property">replace</span> (<span class="regexp">/home/u</span>buntu/hexoblog/node_modules/hexo/lib/plugins/filter/before_post_render/backtick_code_block.<span class="property">js</span>:<span class="number">92</span>:<span class="number">17</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>  是node版本问题,针对于低版本node问题, node12.0.0以上就没有这个问题<br>  node版本12.0.0的Node.js中支持String.matchAll()</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>如果是本地启动报错，升级nodejs版本到12.0.0以上版本</li><li>如果使用了travis CI 打包是出现的，在.travis.yml中，将 node_js对应的参数改为12或12以上版本<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node_js</span>:</span><br><span class="line">  - <span class="number">12</span> # use nodejs v12 <span class="variable constant_">LTS</span></span><br></pre></td></tr></table></figure></li><li>config.xml中的 highlight-&gt;enable的值从true更改为false，也可以避免异常。</li></ul><p>两种解决方法</p><p>① 请将nodejs升级到高于12.0.0的版本。</p><p>② config.xml中的 highlight-&gt;enable的值从true更改为false，这样可以避免异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>readExcel</title>
      <link href="/node/readExcel/"/>
      <url>/node/readExcel/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>随笔记</title>
      <link href="/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
      <url>/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/%E9%9A%8F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="复制链接在url中查看会多一个-–-E2-80-8B"><a href="#复制链接在url中查看会多一个-–-E2-80-8B" class="headerlink" title="复制链接在url中查看会多一个 – %E2%80%8B"></a>复制链接在url中查看会多一个 – %E2%80%8B</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>  测试的时候发现，测试那边发现界面访问界面的去，界面展示不出来接口数据信息，调查日志发现有一个日志报错，认真看这个字符串后边多了一串编码字符</p><h3 id="调查原因："><a href="#调查原因：" class="headerlink" title="调查原因："></a>调查原因：</h3><p>  对“1516004%E2%80%8B”字符串进行范编码格式之后，得到的字符串是“1526004​”，并没有多余的空格和字符存在，是不是很神奇？</p><p>  再继续调查发现 %E2%80%8E 代表的意思是：ZERO-WIDTH SPACE (ZWSP)  零宽度空串，？？？？ 虽然肉眼看不到，但又确实存在？</p><p>  这个字符串一般我们打印是打不出来的，但是通过word等其他文本编辑器拷贝的时候，可能会带有这个字符串，一般是存在url的最后边，怎么验证它是否存在呢？可以将其拷贝到url总就会在自动转化为 %E2%80%8E 这个编码字符，并且可以将鼠标光标放在“1526004​”字符串“前边，然后按删除需要删除两次才能删除到‘4’。</p><h3 id="解决方法：-将url中包含通过替换方式，将这个字符串替换掉即可解决此问题："><a href="#解决方法：-将url中包含通过替换方式，将这个字符串替换掉即可解决此问题：" class="headerlink" title="解决方法： 将url中包含通过替换方式，将这个字符串替换掉即可解决此问题："></a>解决方法： 将url中包含通过替换方式，将这个字符串替换掉即可解决此问题：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = windows.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">replace</span>(<span class="regexp">/%E2%80%8B/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> 日常问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
